今日学习总结与进阶要点
🎯 核心概念回顾
1. LEGB 作用域规则

Local → Enclosing → Global → Built-in 的查找顺序
Python 的静态作用域特性：变量绑定在定义时确定

2. 闭包三要素
def closure_demo():
    """闭包形成的三个条件演示"""
    
    # 条件1: 必须有嵌套函数
    def outer_function(name):
        """外层函数"""
        message = f"Hello, {name}!"  # 外层函数的局部变量
        
        # 条件2: 内层函数必须引用外层函数的变量
        def inner_function():
            """内层函数"""
            return message  # 引用了外层函数的 message 变量
        
        # 条件3: 外层函数必须返回内层函数
        return inner_function  # 返回内层函数对象
    
    return outer_function
嵌套函数结构
内层函数引用外层变量
外层函数返回内层函数

3. nonlocal vs global

nonlocal: 修改嵌套作用域的变量
global: 修改全局作用域的变量
只读访问不需要声明

💡 实际应用场景

配置管理系统 - 今天的项目演示
装饰器实现 - 利用闭包保存状态
事件系统 - 监听器和回调函数
工厂函数 - 根据参数创建特定功能的函数
状态机 - 保持内部状态的函数

🚀 性能与设计考量
闭包 vs 类的选择：

闭包：轻量级、函数式风格、性能更好
类：面向对象、更好的组织结构、支持继承

内存管理：

闭包会保持对外层变量的引用
注意循环引用问题
合理使用 weakref 避免内存泄漏

📝 明天的学习预告
第一周 Day 6: 元编程基础

动态创建类和函数
type() 和元类的初步理解
getattr、setattr、hasattr 动态属性访问
exec() 和 eval() 动态代码执行
实践项目：动态 ORM 查询构建器

🎯 今日练习建议

理解练习：运行所有代码示例，观察输出结果
修改练习：尝试修改配置管理器，添加新功能
应用练习：用闭包实现一个简单的状态机
对比练习：将某个闭包实现改写为类实现

你对今天的闭包和作用域内容还有什么疑问吗？或者想深入了解某个特定的应用场景？明天我们将进入更加神奇的元编程世界！